---
layout:     post
title:      "Dubbo 使用总结"
subtitle:   " \"Dubbo\""
date:       2017-06-08 
author:     "Yang"
header-img: "img/post-bg-alitrip.jpg"
catalog: true
tags:
    - RPC
---

> “on road”
# dubbo 总结

## 概念

### 分布式系统概念

#### 集中式系统
     集中式系统用一句话概括就是：一个主机带多个终端。终端没有数据处理能力，仅负责
     数据的录入和输出。而运算、存储等全部在主机上进行。现在的银行系统，大部分都是
     这种集中式的系统，此外，在大型企业、科研单位、军队、政府等也有分布。集中式系
     统，主要流行于上个世纪。
     
     集中式系统的最大的特点就是部署结构非常简单。因此无需考虑如何对服务进行多节点
     的部署，也就不用考虑各节点之间的分布式协作问题。由于采用单机部署。很可能带来
     系统大而复杂、难于维护、发生单点故障，扩展性差
   
#### 分布式系统
     分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息
     传递进行通信和协调的系统
     
     简单来说就是一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像
     是一台计算机在提供服务一样。分布式意味着可以采用更多的普通计算机（相对于昂贵
     的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越
     多，能够处理的并发访问量也就越大。
     
     分布性(多台计算机之间在空间位置上可以随意分布，系统中的多台计算机之间没有主、
     从之分)  
     透明性(系统资源被所有计算机共享)
     同一性(系统中的若干台计算机可以互相协作来完成一个共同的任务)
     通信性(系统中任意两台计算机都可以通过通信来交换信息)
     
     优点:性价比更高、处理能力更强、可靠性更高、也有很好的扩展性
     缺点:必要条件就是网络，这可能对性能甚至服务能力造成一定的影响

### RPC

     RPC 的全称是 Remote Procedure Call 是一种进程间通信方式。它允许程序调用另一个地
     址空间（通常是共享网络的另一台机器上）的过程或函数，而不用程序员显式编码这个远程调用
     的细节。即程序员无论是调用本地的还是远程的，本质上编写的调用代码基本相同。
     
     RPC 的主要功能目标是让构建分布式计算（应用）更容易，在提供强大的远程调用能力时不损失
     本地调用的语义简洁性。为实现该目标，RPC 框架需提供一种透明调用机制让使用者不必显式的
     区分本地调用和远程调用
     
    同步调用（客户方等待调用执行完成并返回结果)  
    异步调用 （客户方调用后不用等待执行结果返回，但依然可以通过回调通知等方式获取返回结果,
    若客户方不关心调用返回结果，则变成单向异步调用，单向调用不用返回结果)
    
### TCP连接

#### TCP短连接
    client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。短连接一般只会在client/server间传递一次读写操作
    短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段
#### TCP长连接
    client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。
    
    在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。
    
### 序列化

    主要用于存储对象状态为另一种通用格式，比如存储为二进制、xml、json等等，把对象转换成这种格式就叫序列化，而反序列化通常是从这种格式转换回来。

    使用序列化主要是因为跨平台和对象存储的需求，因为网络上只允许字符串或者二进制格式，而文件需要使用二进制流格式，如果想把一个内存中的对象存储下来就必须使用序列化转换为xml（字符串）、json（字符串）或二进制（流）
    
### DUBBO
    Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案
    
    核心部分包含:
	1》远程通讯: 提供对多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应”模式的信息交换方式。
	2》集群容错: 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
	3》自动发现: 基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

#### Dubbo能做什么？

	1.透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。
	2.软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。
	3. 服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的IP地址，并且能够平滑添加或删除服务提供者。
	
	Dubbo通过长连接减少握手，通过NIO及线程池在单连接上并发拼包处理消息，通过二进制流压缩数据，比常规HTTP等短连接协议更快
	
### Netty
    从组网情况看，垂直的架构拆分之后，系统采用分布式部署，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。
    
    Netty 作为高性能的基础通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈，非常方便定制和开发私有协议栈
    
    如果你熟悉TCP/IP，网络编程和NIO，那么Netty难度并不大
    
### NIO
    nio的适用于io高并发场景
    
    如果nio的方式大家排队就好了，开5个窗口能支持100个人来办理业务，但如果是bio，就必须开100个窗口，否则其他人连排队的机会都没有，窗口就相当于线程数，如果开的过多，银行就炸掉了，如果刚开始开5个，多余5个就新开窗口，医院的窗口就是建了拆拆了建，你说耗时不
    
    假如有10000个连接，4核CPU ，那么bio 就需要一万个线程，而nio大概就需要5个线程(一个接收请求，四个处理请求)。如果这10000个连接同时请求，那么bio就有10000个线程抢四个CPU ，几乎每个CPU 平均执行2500次上下文切换，而nio 四个处理线程，几乎每个线程都对应一个CPU ，也就是几乎没有上下文切换。效率就体现出来了
    
    假如有一个饭店，只有一个厨师，如果每天只来一个客人，厨师一个人接待、做饭、上菜和结账，效率很好（没有中间人，直接接受顾客消息）。如果有十个同样的厨师和顾客，效率也是很高。如果顾客再多，厨师无法增加，这个时候一个厨师得服务多个顾客，顾客只能排队，而顾客也不知道啥时候能排到自己，只能死等，不时去问厨师轮到自己没有，这就是BIO。假如你去的是肯德基，流水很快，你等等也无妨，反而你付款后到外面做其他事情会影响效率，BIO这时候依然很快。BIO可以总结为“我要读”，这里是“我要点菜”。如果在一个海鲜酒楼，那就很坑了，你肯定不乐意一直等，这时候怎么提高效率呢？加一个服务员呀，如果没空位，你先把联系方式给服务员，自己就可以去干其他事情了，服务员发现有空余厨师的时候，她会通知你，告诉你可以准备点餐了。这就是NIO，总结一下就是“可以读”了，这里是“我可以点餐了”。如果是异步NIO就更好了，成了“您要的菜已经好了”。
    
    NIO 有一个主要的类Selector,这个类似一个观察者，只要我们把需要探知的socketchannel告诉Selector,我们接着做别的事情，当有事件发生时，他会通知我们，传回一组SelectionKey,我们读取这些Key,就会获得我们刚刚注册过的socketchannel,然后，我们从这个Channel中读取数据，放心，包准能够读到，接着我们可以处理这些数据。

    Selector内部原理实际是在做一个对所注册的channel的轮询访问，不断的轮询(目前就这一个算法)，一旦轮询到一个channel有所注册的事情发生，比如数据来了，他就会站起来报告，交出一把钥匙，让我们通过这把钥匙来读取这个channel的内容。
    
## 使用
    Dubbo采用全Spring配置方式，透明化接入应用，对应用没有任何API侵入，只需用Spring加载Dubbo的配置即可，Dubbo基于Spring的Schema扩展进行加载。
    
### 注册中心、消费者、提供者搭建实例

###  1) 安装启动zookeeper
       http://blog.csdn.net/whereismatrix/article/details/50420099

####  2) dubbo-admin管理平台搭建
    为了更好的调试，发现问题，解决问题，因此引入dubbo-admin。通过dubbo-admin可以对消费者和提供者进行管理。
    详情可见:http://blog.csdn.net/u013142781/article/details/50396621
    
####  3) 配置提供者
    https://www.kancloud.cn/digest/javaframe/125576
    
####  4) 配置消费者    
    https://www.kancloud.cn/digest/javaframe/125576
    
#### 说明：
	   dubbo:registry 标签一些属性的说明：
	      1）register是否向此注册中心注册服务，如果设为false，将只订阅，不注册。
	      2）check注册中心不存在时，是否报错。
	      3）subscribe是否向此注册中心订阅服务，如果设为false，将只注册，不订阅。
	      4）timeout注册中心请求超时时间(毫秒)。
	      5）address可以Zookeeper集群配置，地址可以多个以逗号隔开等。
	  dubbo:service标签的一些属性说明：
	     1）interface服务接口的路径
	     2）ref引用对应的实现类的Bean的ID
	     3）registry向指定注册中心注册，在多个注册中心时使用，值为<dubbo:registry>的id属性，多个注册中心ID用逗号分隔，如果不想将该服务注册到任何registry，可将值设为N/A
	     4）register 默认true ，该协议的服务是否注册到注册中心。	  
	   dubbo:reference 的一些属性的说明：
	      1）interface调用的服务接口
	      2）check 启动时检查提供者是否存在，true报错，false忽略
	      3）registry 从指定注册中心注册获取服务列表，在多个注册中心时使用，值为<dubbo:registry>的id属性，多个注册中心ID用逗号分隔
	      4）loadbalance 负载均衡策略，可选值：random,roundrobin,leastactive，分别表示：随机，轮循，最少活跃调用
   



## 原理

### PRC原理
   ![](file:////Users/yang/Desktop/rpc.png)
   
    这里 user 就是 client 端，当 user 想发起一个远程调用时，它实际是通过本地调用 
    user-stub。user-stub 负责将调用的接口、方法和参数通过约定的协议规范进行编码并通过
    本地的 RPCRuntime 实例传输到远端的实例。远端 RPCRuntime 实例收到请求后交给 
    server-stub 进行解码后发起本地端调用，调用结果再返回给 user 端。
    
   ![](file:////Users/yang/Desktop/rpc-detail.png)
   
    RPC 服务方通过 RpcServer 去导出（export）远程接口方法，而客户方通过 RpcClient 去引入（import）远程接口方法。客户方像调用本地方法一样去调用远程接口方法，RPC 框架提供接口的代理实现，实际的调用将委托给代理RpcProxy 。代理封装调用信息并将调用转交给RpcInvoker 去实际执行。在客户端的RpcInvoker 通过连接器RpcConnector 去维持与服务端的通道RpcChannel，并使用RpcProtocol 执行协议编码（encode）并将编码后的请求消息通过通道发送给服务方。
    RPC 服务端接收器 RpcAcceptor 接收客户端的调用请求，同样使用RpcProtocol 执行协议解码（decode）。解码后的调用信息传递给RpcProcessor 去控制处理调用过程，最后再委托调用给RpcInvoker 去实际执行并返回调用结果。
    
    1. RpcServer  
	   负责导出（export）远程接口  
	2. RpcClient  
	   负责导入（import）远程接口的代理实现  
	3. RpcProxy  
	   远程接口的代理实现  
	4. RpcInvoker  
	   客户方实现：负责编码调用信息和发送调用请求到服务方并等待调用结果返回  
	   服务方实现：负责调用服务端接口的具体实现并返回调用结果  
	5. RpcProtocol  
	   负责协议编/解码  
	6. RpcConnector  
	   负责维持客户方和服务方的连接通道和发送数据到服务方  
	7. RpcAcceptor  
	   负责接收客户方请求并返回请求结果  
	8. RpcProcessor  
	   负责在服务方控制调用过程，包括管理调用线程池、超时时间等  
	9. RpcChannel  
	   数据传输通道  
   
### dubbo原理   
   ![](file:////Users/yang/Desktop/dubbo.jpg)
   
    节点角色说明：
	Provider: 暴露服务的服务提供方。
	Consumer: 调用远程服务的服务消费方。
	Registry: 服务注册与发现的注册中心。
	Monitor: 统计服务的调用次调和调用时间的监控中心。
	Container: 服务运行容器。
	
	调用关系说明：
	0 服务容器负责启动，加载，运行服务提供者。
	1 服务提供者在启动时，向注册中心注册自己提供的服务。
	2 服务消费者在启动时，向注册中心订阅自己所需的服务。
	3 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
	4 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
	5 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。
	
### Dubbo如何一步一步拿到bean
    基于Spring可扩展Schema提供自定义配置支持。dubbo是依赖spring提供的这种机制来处理配置文件解析的
    在很多情况下，我们需要为系统提供可配置化支持，简单的做法可以直接基于Spring的标准Bean来配置，但配置较为复杂或者需要更多丰富控制的时候，会显得非常笨拙。一般的做法会用原生态的方式去解析定义好的xml文件，然后转化为配置对象，这种方式当然可以解决所有问题，但实现起来比较繁琐，特别是是在配置非常复杂的时候，解析工作是一个不得不考虑的负担。Spring提供了可扩展Schema的支持，这是一个不错的折中方案，完成一个自定义配置一般需要以下步骤：

	设计配置属性和JavaBean 
	编写XSD文件 
	编写NamespaceHandler和BeanDefinitionParser完成解析工作 
	编写spring.handlers和spring.schemas串联起所有部件 
	在Bean文件中应用 
	
#### xml -> beanDefinition

    按照spring提供的机制，dubbo把每个自定义的可使用配置元素和对应的解析器绑定到一起。而真正负责把配置文件中声明的内容解析成对应的BeanDefinition（可以想象为Bean的模子）是靠DubboBeanDefinitionParser.parse类完成
    dubbo就已经把配置文件中定义的bean全部解析成对应的beanDefinition，为spring的getBean做好准备工作。

##### beanDefinition -> bean
    http://songzi0206.iteye.com/blog/1430239#show-last-Point
    其实也就是从beanDefinition转换成bean的过程,dubbo就是委托给spring来管理bean的生命周期的
    spring解析生成的beanDefinition并没有dubbo特殊性，交给默认的BeanFactory没啥问题
    
#### bean -> service
    最终都会被转换成字符串以URL的形式交给dubbo的底层最终暴露成服务


